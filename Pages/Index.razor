@using System.Text.Json 
@using System.Text 
@using System.Net.Http.Headers
@using System.IO 

@page "/"
@inject HttpClient Http

@inject IJSRuntime JSRuntime

<div class="cards-container">
    <div class="texts">
                <h1>Welcome to bg remover.</h1>
                <h1>Let's get rid of that background!</h1>
            </div>
    <div class="upload">
        <div class="upload-content">
            
            <InputFile class="custom-file-input" multiple OnChange="OnChange" accept="image/png, image/jpeg, image/gif" id="inputFile" />
            <label for="inputFile" class="button">Upload Image</label>   
            @* <p1 class="text">Or drop it</p1> *@
        </div> 
        </div>
        @if (!imageUploaded) {
    
}
<div class="display">
    <div class="display-content">
     @foreach (var item in filesBase64.Select((file, index) => new { file, index }))
{
    
    <div class="image-container">
        <img src="data:@item.file.contentType;base64,@item.file.base64data" />
    </div>
}

    </div>
    <div class="action-buttons">
        @if (imageUploaded) {
        <div class="remove-bg">
            <button class="btn btn-secondary" @onclick="RemoveBackgrounds">Remove Backgrounds</button>
        </div>
            <button class="btn btn-danger" @onclick="DeleteLastImage">Delete Last Image</button>
            <button class="btn btn-primary" @onclick="DownloadImage">Download Image</button>

        }
    </div>
    @if (!imageUploaded) {
    <h1 class="title">Your Image</h1>
}

</div>

</div>



@code {
    List<ImageFile> filesBase64 = new List<ImageFile>();
    List<byte[]> originalImages = new List<byte[]>(); // Store original images for background removal
    string message = "Choose your picture!";
    bool isDisabled = false;
    string removeBgApiKey = "P9GzszacRRhUFJc68TkW2aoh"; // Replace with your actual API key
    bool imageUploaded = false; // Flag to track image upload

    async Task OnChange(InputFileChangeEventArgs e)
{   
    // Your logic to handle the file upload starts here
    originalImages.Clear(); // Clear previous images
    filesBase64.Clear(); // Optionally clear previous displayed images
    var files = e.GetMultipleFiles();
    foreach(var file in files)
    {
        var resizedFile = await file.RequestImageFileAsync(file.ContentType, 640, 480);
        var buf = new byte[resizedFile.Size];
        using (var stream = resizedFile.OpenReadStream())
        {
            await stream.ReadAsync(buf);
        }

        originalImages.Add(buf); // Store original image data for later processing

        // Convert and store the image for display
        var base64Image = Convert.ToBase64String(buf);
        filesBase64.Add(new ImageFile { base64data = base64Image, contentType = file.ContentType, fileName = file.Name });
    }

    // After successfully adding images, update the flag to indicate an image has been uploaded
    imageUploaded = true;
    StateHasChanged();
}

// You can refactor the code from OnChange to a new method, e.g., ProcessUploadedFiles, and call it both from OnChange and OnDrop.



    async Task RemoveBackgrounds()
    {
        for (int i = 0; i < originalImages.Count; i++)
        {
            var base64Image = Convert.ToBase64String(originalImages[i]);
            var response = await RemoveBackground(base64Image);
            if (response != null)
            {
                filesBase64[i] = new ImageFile { base64data = response, contentType = "image/png", fileName = filesBase64[i].fileName }; // Update image with removed background
            }
        }
        StateHasChanged(); // Refresh UI to display the updated images
    }
void DeleteLastImage()
{
    if (filesBase64.Any())
    {
        filesBase64.RemoveAt(filesBase64.Count - 1);
        if (filesBase64.Count == 0)
        {
            imageUploaded = false; // No images left, show the title again
        }
    }
    StateHasChanged(); // Refresh the UI
}
async Task DownloadImage()
{
    if (filesBase64.Any())
    {
        var image = filesBase64.Last(); // Assuming you want to download the last image in the list
        await JSRuntime.InvokeVoidAsync("saveAsFile", image.fileName, image.base64data);
    }
}



  async Task<string?> RemoveBackground(string base64Image)
{
    var requestContent = new StringContent(JsonSerializer.Serialize(new
    {
        image_file_b64 = base64Image,
        size = "auto"
    }), Encoding.UTF8, "application/json");

    requestContent.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json");
    requestContent.Headers.Add("X-Api-Key", "1StRVGgX82WmpgCnZhgGepYe");

    var response = await Http.PostAsync("https://api.remove.bg/v1.0/removebg", requestContent);
    if (response.IsSuccessStatusCode)
    {
        using (var responseStream = await response.Content.ReadAsStreamAsync())
        using (var memoryStream = new MemoryStream())
        {
            await responseStream.CopyToAsync(memoryStream);
            var resultImageBytes = memoryStream.ToArray();
            return Convert.ToBase64String(resultImageBytes);
        }
    }
    else
    {
        // Return null or an appropriate default value if the API call fails
        return null;
    }
}
}
